const path = require("path");
const { groth16 } = require('snarkjs');
const fs = require('fs');
const { constants, BigNumber, BigNumberish } = require("ethers");


async function getListProof(
	PLANETHASH_KEY,
	BIOMEBASE_KEY,
	SPACETYPE_KEY,
	SCALE,
	xMirror,
	yMirror,
	listing_id,
	nonce,
	key_commitment,
	planet_id,
	biomebase,
	seller_address,
	x,
	y,
	key
) {
	const inputs = {
		PLANETHASH_KEY,
		BIOMEBASE_KEY,
		SPACETYPE_KEY,
		SCALE,
		xMirror,
		yMirror,
		listing_id,
		nonce,
		key_commitment,
		planet_id,
		biomebase,
		seller_address,
		x,
		y,
		key
	};

	// Calculate witness and create proof.
	// TODO fix ts filepath issues
	const { proof, publicSignals } = await groth16.fullProve(
		inputs,
		path.join(__dirname, "..", "..", "..", "client", "list", "list.wasm"),
		path.join(__dirname, "..", "..", "..", "client", "list", "list.zkey"),
	);
	// /message sender is 0.
	// console.log(proof, null, 1);

	const callArgs = buildContractCallArgs(proof, [listing_id, nonce, key_commitment, planet_id, biomebase]);
	console.log(callArgs);

	// TODO: convert proof into trx friendly format
	return callArgs
}


/**
 * A zkSNARK proof (without signals) generated by snarkJS `fullProve`
 */
interface SnarkJSProof {
	pi_a: [string, string, string];
	pi_b: [[string, string], [string, string], [string, string]];
	pi_c: [string, string, string];
}

// type ContractCallArgs = ListContractCallArgs; // SaleContractCallArgs
/**
 * Method for converting the output of snarkJS `fullProve` into args that can be
 * passed into DarkForestCore smart contract functions which perform zk proof
 * verification.
 *
 * @param snarkProof the SNARK proof
 * @param publicSignals the circuit's public signals (i.e. output signals and
 * public input signals)
 */
function buildContractCallArgs(
	proof: SnarkJSProof,
	publicSignals: string[]
) {
	return [
		[BigNumber.from(proof.pi_a[0]),
		BigNumber.from(proof.pi_a[1]),
		BigNumber.from(proof.pi_b[0][1]),
		BigNumber.from(proof.pi_b[0][0]),
		BigNumber.from(proof.pi_b[1][1]),
		BigNumber.from(proof.pi_b[1][0]),
		BigNumber.from(proof.pi_c[0]),
		BigNumber.from(proof.pi_c[1])],
		[BigNumber.from(publicSignals[0][0]),
		BigNumber.from(publicSignals[0][1]),
		BigNumber.from(publicSignals[0][2]),
		BigNumber.from(publicSignals[0][3])],
		BigNumber.from(publicSignals[1]),
		BigNumber.from(publicSignals[2]),
		BigNumber.from(publicSignals[3]),
		BigNumber.from(publicSignals[4]),
	];
}

// async function verifyListProof(proof) {
// 	const vKey = JSON.parse(fs.readFileSync("../list/list.vkey.json"));

// 	const res = await groth16.verify(vKey, publicSignals, proof);

// 	if (res === true) {
// 		console.log("Verification OK");
// 		return true;
// 	} else {
// 		console.log("Invalid proof");
// 		return false;
// 	}
// 	// await fetch(vkpath) top get vkey
// 	// await groth16.verify(vkey, publicInputs, proof);
// }

module.exports = {
	getListProof,
	// verifyListProof
}